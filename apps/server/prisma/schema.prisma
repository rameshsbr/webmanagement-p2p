// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// Cascading deletes are intentionally avoided to preserve historical financial and audit data.
// Relations should use RESTRICT or SET NULL semantics; full cleanup must be performed explicitly.

/**
 * ───────── EXISTING MODELS (kept as-is, only added safe relations) ─────────
 */
model Merchant {
  id               String                    @id @default(cuid())
  name             String
  webhookUrl       String?
  balanceCents     Int                       @default(0)
  status           String                    @default("active")
  apiKeys          MerchantApiKey[]
  bankAccounts     BankAccount[]
  paymentReqs      PaymentRequest[]
  ledger           LedgerEntry[]
  accountEntries   MerchantAccountEntry[]
  apiKeyRevealLogs MerchantApiKeyRevealLog[]
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  channels         NotificationChannel[]

  email                     String? // NEW: optional
  defaultCurrency           String  @default("USD") // NEW: required with default
  active                    Boolean @default(true)
  userDirectoryEnabled      Boolean @default(false)
  /// When false, Merchant Portal cannot create/rotate API keys.
  apiKeysSelfServiceEnabled Boolean @default(true)

  // new relations for super-admin features
  limits         MerchantLimits?
  blocklist      PayerBlocklist[]
  clientMappings MerchantClient[]

  // NEW: per-merchant Didit KYC workflow ID
  diditWorkflowId String?

  // NEW: per-merchant checkout/SDK form configuration
  // (stored in MerchantFormConfig; one merchant can have many, incl. per-bank)
  formConfigs   MerchantFormConfig[]
  merchantUsers MerchantUser[]

  // NEW: configured payment methods
  methods MerchantMethod[]
}

model MerchantApiKey {
  id String @id @default(cuid())

  merchant   Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  merchantId String

  prefix    String   @unique
  secretEnc String
  last4     String
  scopes    String[] @default([])
  active    Boolean  @default(true)

  createdAt  DateTime                  @default(now())
  lastUsedAt DateTime?
  expiresAt  DateTime?
  revealLogs MerchantApiKeyRevealLog[]

  @@index([merchantId])
}

model User {
  id           String  @id @default(cuid())
  publicId     String  @unique
  email        String? @unique
  phone        String?
  fullName     String?
  diditSubject String? @unique

  firstName              String?
  lastName               String?
  documentType           String?
  documentNumber         String?
  documentIssuingState   String?
  documentIssuingCountry String?
  dateOfBirth            DateTime?
  documentExpiry         DateTime?
  gender                 String?
  address                String?
  verifiedAt             DateTime?
  kyc                    KycVerification[]
  paymentReqs            PaymentRequest[]
  withdrawDests          WithdrawalDestination[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt

  // NEW: back-reference for PayerBlocklist.user
  blocklistEntries PayerBlocklist[]
  merchantClients  MerchantClient[]
}

model KycVerification {
  id                String   @id @default(cuid())
  userId            String?
  user              User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  provider          String
  status            String // pending|approved|rejected
  externalSessionId String   @unique
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model BankAccount {
  id         String    @id @default(cuid())
  merchantId String?
  merchant   Merchant? @relation(fields: [merchantId], references: [id], onDelete: SetNull)

  publicId     String  @unique @default(dbgenerated("'B' || lpad(nextval('bank_public_id_seq')::text, 4, '0')")) @db.VarChar(32)
  currency     String
  holderName   String
  bankName     String
  accountNo    String
  iban         String?
  instructions String?

  depositMinAmountCents   Int?
  depositMaxAmountCents   Int?
  withdrawMinAmountCents  Int?
  withdrawMaxAmountCents  Int?

  // Phase-2 fields
  method String  @default("OSKO") // OSKO | PAYID | FPX | DUITNOW | etc.
  label  String? // friendly name for UI

  fields Json? // { core: {holderName:{visible}, bankName:{visible}, accountNo:{visible}, iban:{visible}}, extra: [{key,label,type,value,visible,order}] }

  active    Boolean  @default(true)
  createdAt DateTime @default(now())

  payments PaymentRequest[] @relation("BankToPayment")

  // Opposite side of MerchantFormConfig.bankAccount
  formConfigs MerchantFormConfig[]

  @@index([merchantId, currency, method, active])
}

model Method {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  enabled   Boolean  @default(true) @map("active")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  depositMinAmountCents  Int?
  depositMaxAmountCents  Int?
  withdrawMinAmountCents Int?
  withdrawMaxAmountCents Int?

  merchantLinks   MerchantMethod[]
  paymentRequests PaymentRequest[]
}

model MerchantMethod {
  id         String   @id @default(cuid())
  merchant   Merchant @relation(fields: [merchantId], references: [id])
  merchantId String

  method   Method @relation(fields: [methodId], references: [id])
  methodId String

  enabled Boolean @default(true)
  depositEnabled    Boolean @default(true)
  withdrawalEnabled Boolean @default(true)

  createdAt DateTime @default(now())

  @@unique([merchantId, methodId])
}

model ReceiptFile {
  id        String   @id @default(cuid())
  path      String
  mimeType  String
  size      Int
  original  String
  createdAt DateTime @default(now())

  // OLD 1:1 backref (keep during transition)
  payment PaymentRequest? @relation("ReceiptToPayment")

  // NEW multi-receipt relation (Phase 2, nullable for backfill)
  paymentId String?
  paymentV2 PaymentRequest? @relation("PaymentReceipts", fields: [paymentId], references: [id], onDelete: SetNull)

  accountEntry MerchantAccountEntry? @relation("AccountEntryReceipt")

  @@index([paymentId, createdAt])
}

model NotificationChannel {
  id         String                @id @default(cuid())
  merchantId String
  type       NotificationType
  chatId     String
  direction  NotificationDirection @default(BOTH)
  active     Boolean               @default(true)
  createdAt  DateTime              @default(now())

  merchant Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)

  @@unique([merchantId, type, chatId, direction])
  @@index([merchantId])
}

enum PaymentType {
  DEPOSIT
  WITHDRAWAL
}

enum PaymentStatus {
  PENDING
  SUBMITTED
  APPROVED
  REJECTED
}

enum NotificationType {
  TELEGRAM
}

enum NotificationDirection {
  INCOMING
  OUTGOING
  BOTH
}

model PaymentRequest {
  id              String        @id @default(cuid())
  type            PaymentType
  status          PaymentStatus @default(PENDING)
  amountCents     Int
  currency        String
  referenceCode   String        @unique
  uniqueReference String        @unique

  methodId String?
  method   Method? @relation(fields: [methodId], references: [id], onDelete: SetNull)

  processedByAdminId String?
  processedByAdmin   AdminUser? @relation("PaymentProcessedBy", fields: [processedByAdminId], references: [id], onDelete: SetNull)
  processedAt        DateTime?

  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  bankAccountId String?
  bankAccount   BankAccount? @relation("BankToPayment", fields: [bankAccountId], references: [id], onDelete: SetNull)

  // OLD single receipt (kept)
  receiptFileId String?      @unique
  receiptFile   ReceiptFile? @relation("ReceiptToPayment", fields: [receiptFileId], references: [id], onDelete: SetNull)

  // NEW multi-receipt (Phase 2)
  receipts ReceiptFile[] @relation("PaymentReceipts")

  detailsJson          Json?
  rejectedReason       String?
  notes                String? // ← added so superadmin notes route works
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  ProviderPayment      ProviderPayment?
  ProviderDisbursement ProviderDisbursement[]

  @@index([processedByAdminId])
}

model WithdrawalDestination {
  id         String   @id @default(cuid())
  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  currency   String
  bankName   String
  holderName String
  accountNo  String
  iban       String?
  createdAt  DateTime @default(now())
}

model LedgerEntry {
  id          String   @id @default(cuid())
  merchantId  String
  merchant    Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  amountCents Int // + credit, - debit
  reason      String
  paymentId   String?
  createdAt   DateTime @default(now())
}

enum MerchantAccountEntryType {
  TOPUP
  SETTLEMENT
}

model MerchantAccountEntry {
  id            String                   @id @default(cuid())
  merchantId    String
  merchant      Merchant                 @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  type          MerchantAccountEntryType
  method        String?
  amountCents   Int
  note          String?
  receiptFileId String?                  @unique
  receiptFile   ReceiptFile?             @relation("AccountEntryReceipt", fields: [receiptFileId], references: [id], onDelete: SetNull)
  createdById   String?
  createdBy     AdminUser?               @relation("AccountEntryCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  createdAt     DateTime                 @default(now())

  @@index([merchantId, type, createdAt])
  @@index([createdAt])
}

/**
 * ───────── NEW / UPDATED FOR SUPER ADMIN ─────────
 */

enum AdminRole {
  SUPER
  ADMIN
  SUPPORT
}

model AdminUser {
  id                       String    @id @default(cuid())
  email                    String    @unique
  passwordHash             String
  role                     String    @default("admin") // "SUPER" or "ADMIN" (string for now)
  active                   Boolean   @default(true)
  displayName              String?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @default(now()) @updatedAt // ← add default so backfill works
  twoFactorEnabled         Boolean   @default(false)
  totpSecret               String?
  superTwoFactorEnabled    Boolean   @default(false)
  superTotpSecret          String?
  timezone                 String?
  lastLoginAt              DateTime?
  canViewUserDirectory     Boolean   @default(true)
  canRevealMerchantApiKeys Boolean   @default(false)

  auditLogs         AdminAuditLog[]
  loginLogs         AdminLoginLog[]
  resetTokens       AdminPasswordReset[]
  processedPayments PaymentRequest[]          @relation("PaymentProcessedBy")
  accountEntries    MerchantAccountEntry[]    @relation("AccountEntryCreatedBy")
  apiKeyRevealLogs  MerchantApiKeyRevealLog[]
}

model AdminLoginLog {
  id        String     @id @default(cuid())
  adminId   String?
  admin     AdminUser? @relation(fields: [adminId], references: [id], onDelete: SetNull)
  email     String?
  success   Boolean
  ip        String?
  userAgent String?
  createdAt DateTime   @default(now())

  @@index([adminId])
  @@index([email])
}

model AdminAuditLog {
  id         String     @id @default(cuid())
  adminId    String?
  admin      AdminUser? @relation(fields: [adminId], references: [id], onDelete: SetNull)
  action     String
  targetType String?
  targetId   String?
  ip         String?
  meta       Json?
  createdAt  DateTime   @default(now())

  @@index([adminId])
  @@index([targetType, targetId])
}

enum MerchantRole {
  OWNER
  MANAGER
  ANALYST
}

model MerchantUser {
  id                   String       @id @default(cuid())
  merchantId           String
  merchant             Merchant     @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  email                String       @unique
  passwordHash         String
  role                 MerchantRole @default(MANAGER)
  active               Boolean      @default(true)
  twoFactorEnabled     Boolean      @default(false)
  totpSecret           String?
  timezone             String?
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  lastLoginAt          DateTime?
  canViewUserDirectory Boolean      @default(true)
  canRevealApiKeys     Boolean      @default(false)

  loginLogs        MerchantLoginLog[]
  resetTokens      MerchantPasswordReset[]
  apiKeyRevealLogs MerchantApiKeyRevealLog[]

  @@index([merchantId])
}

model MerchantLoginLog {
  id             String        @id @default(cuid())
  merchantUserId String?
  merchantUser   MerchantUser? @relation(fields: [merchantUserId], references: [id], onDelete: SetNull)
  email          String?
  success        Boolean
  ip             String?
  userAgent      String?
  createdAt      DateTime      @default(now())

  @@index([merchantUserId])
  @@index([email])
}

model MerchantClient {
  id         String       @id @default(cuid())
  merchantId String
  userId     String?
  externalId String?
  email      String?
  status     ClientStatus @default(ACTIVE)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  merchant Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([merchantId, userId])
  @@unique([merchantId, externalId])
  @@index([merchantId])
  @@index([userId])
}

enum ClientStatus {
  ACTIVE
  DEACTIVATED
  BLOCKED
}

model MerchantLimits {
  merchantId   String   @id
  merchant     Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  maxReqPerMin Int?
  ipAllowList  String[] @default([])
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model PayerBlocklist {
  id         String    @id @default(cuid())
  merchantId String?
  merchant   Merchant? @relation(fields: [merchantId], references: [id], onDelete: SetNull)
  userId     String?
  user       User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  reason     String?
  active     Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@unique([merchantId, userId])
  @@index([merchantId])
  @@index([userId])
}

model AdminPasswordReset {
  id        String     @id @default(cuid())
  adminId   String?
  admin     AdminUser? @relation(fields: [adminId], references: [id], onDelete: SetNull)
  token     String     @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime   @default(now())

  @@index([adminId])
}

model MerchantPasswordReset {
  id             String        @id @default(cuid())
  merchantUserId String?
  merchantUser   MerchantUser? @relation(fields: [merchantUserId], references: [id], onDelete: SetNull)
  token          String        @unique
  expiresAt      DateTime
  usedAt         DateTime?
  createdAt      DateTime      @default(now())

  @@index([merchantUserId])
}

model MerchantApiKeyRevealLog {
  id               String         @id @default(cuid())
  merchantApiKeyId String
  merchantApiKey   MerchantApiKey @relation(fields: [merchantApiKeyId], references: [id], onDelete: Restrict)
  merchantId       String
  merchant         Merchant       @relation(fields: [merchantId], references: [id], onDelete: Restrict)
  actorType        String
  merchantUserId   String?
  merchantUser     MerchantUser?  @relation(fields: [merchantUserId], references: [id], onDelete: SetNull)
  adminUserId      String?
  adminUser        AdminUser?     @relation(fields: [adminUserId], references: [id], onDelete: SetNull)
  reason           String?
  outcome          String
  ip               String?
  userAgent        String?
  createdAt        DateTime       @default(now())

  @@index([merchantApiKeyId, createdAt])
  @@index([merchantUserId, createdAt])
  @@index([adminUserId, createdAt])
  @@index([merchantId, createdAt])
}

model IdempotencyKey {
  id        String   @id @default(cuid())
  scope     String
  key       String
  response  Json
  createdAt DateTime @default(now())

  @@unique([scope, key])
}

/**
 * ───────── UPDATED: Per-merchant *and/or* per-bank Form Configuration ─────────
 * If bankAccountId is NULL ⇒ merchant-level default.
 * Unique per (merchantId, bankAccountId).
 */
model MerchantFormConfig {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id], onDelete: Restrict)

  bankAccountId String?
  // Keep configuration rows even if a bank account is deleted; avoid cascading loss of settings.
  bankAccount   BankAccount? @relation(fields: [bankAccountId], references: [id], onDelete: SetNull)

  // JSON arrays of { name,display,field,placeholder,required,minDigits?,maxDigits?,options? }
  deposit    Json?
  withdrawal Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([merchantId, bankAccountId])
}

// --- BEGIN: provider integration tables ---

model ProviderPayment {
  id               String         @id @default(cuid())
  paymentRequestId String         @unique
  paymentRequest   PaymentRequest @relation(fields: [paymentRequestId], references: [id])

  provider          String // 'FAZZ'
  providerPaymentId String @unique   // Fazz payment id
  methodType        String // 'virtual_bank_account'
  bankCode          String?
  accountNumber     String?
  accountName       String?
  expiresAt         DateTime?
  status            String // pending/paid/completed/failed/expired...
  instructionsJson  Json?
  rawCreateJson     Json?
  rawLatestJson     Json?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

model ProviderDisbursement {
  id               String          @id @default(cuid())
  paymentRequestId String?
  paymentRequest   PaymentRequest? @relation(fields: [paymentRequestId], references: [id])

  provider         String // 'FAZZ'
  providerPayoutId String  @unique
  bankCode         String
  accountNumber    String
  accountHolder    String
  status           String
  validationStatus String?
  amountCents      Int
  currency         String
  rawCreateJson    Json?
  rawLatestJson    Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ProviderWebhookLog {
  id          String    @id @default(cuid())
  provider    String // 'FAZZ'
  topic       String
  signature   String?
  headersJson Json?
  payloadJson Json?
  processed   Boolean   @default(false)
  error       String?
  createdAt   DateTime  @default(now())
  processedAt DateTime?
}

// Optional: static VA binding per user/merchant
model PaymentMethodBinding {
  id          String   @id @default(cuid())
  provider    String // 'FAZZ'
  merchantId  String
  userId      String
  methodType  String // 'virtual_bank_account'
  bankCode    String
  accountNo   String
  accountName String
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([provider, merchantId, userId, methodType, bankCode])
}

// Optional fee engine — only if you haven’t added it yet
enum FeeKind {
  FIXED
  PERCENTAGE
}

model FeeRule {
  id          String   @id @default(cuid())
  merchantId  String
  methodId    String
  kind        FeeKind
  amountCents Int?
  percentBps  Int?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([merchantId, methodId, active])
}

// --- END: provider integration tables ---
